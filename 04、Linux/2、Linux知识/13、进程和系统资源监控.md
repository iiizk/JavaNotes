[TOC]

# 进程

## 概念

> 进程通俗来说，进程就是运行中的程序
>
> 在linux下，知道程序要运行，首先就是将磁盘中相应的可执行文件加载到内存中，那么我们怎么知道他在内存中哪呢？这个时候就需要我们通过一个叫做进程标识符的东西找到它。类似于我们自己的身份证
>
> 进程分为临时进程和持久进程
>
> - 临时进程：执行完命令，自动结束
> - 持久进程/守护进程：程序执行后，需要手动结束

## 程序被加载为进程的过程

1. 用户执行程序
2. 程序加载到内存中
   - 给程序一个临时的PID
   - 查看执行的全限，如果用户没有执行全限，那么拒绝操作；如果有，开始加载程序执行的相关资料（内存指针开始扫描相应的数据或者代码）
   - 确认临时的PID

![](https://gitee.com/sxhDrk/images/raw/master/imgs/结束某个进行.png)



# 查看进程

> 在Linux系统中，不像windows那样方便，可以通过快捷键调出图形化的任务管理器来管理进程。

## 静态查询

### `PS`

> 将某个时间点的程序运作情况截取下来
>
> 常用组合选项 `-aux`
>
> | 选项 | 作用                                                |
> | ---- | --------------------------------------------------- |
> | a    | 关联的所有 process，通常与x一起使用，列出完整信息。 |
> | x    | 后台进程                                            |
> | u    | 有效使用者的相关联的进程                            |
> | ajxf | 可以让ps的结果以树状的格式显示出来。                |
>
> 举例:当我们新开一个通道编辑一个文件的时候，我们通过`ps -aux`可以查看到

#### 查询指定进程

> `ps -aux | grep sshd`

1. ps查询结果各项解释

   | 结果    | 解释                                                         |
   | ------- | ------------------------------------------------------------ |
   | USER    | 用户                                                         |
   | PID     | 进程ID                                                       |
   | %CPU    | cpu占用率                                                    |
   | %MEM    | 内存使用率                                                   |
   | VSS     | 虚拟内存使用量                                               |
   | RSS     | 物理内存使用量                                               |
   | TTY     | tty1-tty6  是本机上面的登入者程序。  pts/0  等等的,则表示为由网络连接进主机的程序。  如果显示？则表示与终端机无关。 |
   | STAT    | 进程的状态                                                   |
   | START   | 进程启动的时间                                               |
   | TIME    | 累计消耗CPU的时间                                            |
   | COMMAND | 表示哪个命令/程序运行的该进程                                |

2. 状态标识

   | 状态  | 解释                           |
   | ----- | ------------------------------ |
   | ==R== | ==正在运行，或在队列中的进程== |
   | ==S== | ==处于休眠状态==               |
   | l     | 多进程                         |
   | Z     | 僵尸进程                       |
   | T     | 停止或者被追踪                 |
   | ==<== | ==高优先级==                   |
   | ==N== | ==低优先级==                   |
   | ==s== | ==包含子进程==                 |
   | ==+== | ==位于后台的进程组==           |

3. 僵尸进程

   > 由于该进程已经执行完毕，但是父进程没有终止或其他原因导致该进程并没有真正的结束，所形成的进程称之为僵尸进程。
   >
   > 此进程对服务器的危害在于它会持续的消耗服务器资源，消耗量会越来越大。最终导致其他的进程无资源可用，服务器崩溃。

### `pstree`

> 语法:`pstree [选项]`
>
> 选项:
>
> | 选项  | 作用                                |
> | ----- | ----------------------------------- |
> | A     | 各程序之间的连接以ASCII字符来连接   |
> | U     | 各程序之间的连接以UTF-8的字符来连接 |
> | ==u== | ==列出每个process的所属账号名称==   |
> | ==p== | ==同时列出每个程序的进程的ID==      |

1. 举例

   ```shell
   [root@Demo01 ~]# pstree -up 
   ```

   

## 动态查询:`top`

> 动态查询系统的进程状态。默认是3秒一更新。
>
> 选项：
>
> | 选项        | 作用                                                         |
> | ----------- | ------------------------------------------------------------ |
> | -d          | 跟时间，可以修改top默认更新(刷新)的时间                      |
> | -b :        | 以批次的方式执行 top  ,还有更多的参数可以使用,通常会搭配数据流 重导向来将批次的结果输出成为档案; |
> | -n Number： | 与 -b 搭配,意义是需要进行几次 top  的输出结果;               |
> | -p :        | 指定某些个 PID 来进行观察监测而已;                           |

### 使用案例

1. 每秒刷新一次top

   ```shell
   [root@Demo01 ~]# top -d 1
   ```

   

2. 每2秒刷新一次top，以批次输出2次

   ```shell
   [root@Demo01 ~]# -d 2 -n 2
   ```

   

3. 每秒刷新一次top，以批次输出5次

   ```sh
   [root@Demo01 ~]# top -d 1 -b -n 5  >> top.log
   ```

   

### 交互式案件：（不常用）

| 按键 | 作用                                       |
| ---- | ------------------------------------------ |
| ?    | 显示在 top 当中可以输入的按键指令          |
| P    | 以CPU的使用资源排序显示                    |
| M    | 以Memory的使用资源排序显示                 |
| N    | 以PID来排序                                |
| T    | 由该Process使用的CPU时间累积  (TIME+) 排序 |
| q    | 离开top软件的按键                          |



# 进程的管理

## 单进程的管理

> `kill`：结束某个进程

语法：`kill 信号量 PID`

信号量：

| 信号量 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| -15    | 以正常的程序方式终止一个进程！！！                           |
| -9     | 立刻强制终止一个进程！！！（！！不能强制结束系统级别的进程） |
| -2     | 代表由键盘输入 [ctrl] + c  同样的动作;                       |
| -1     | 对于sshd这样的守护进程，重新读取一次参数的配置文件      (类似 reload)，如果进程为非守护进程，默认为终止进程; ！！ |



## 多进程的管理

> `killall`：结束基于某个程序运行进程

语法：`killall 信号量 程序名/命令名`

信号量：

| 信号量 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| -15    | 以正常的程序方式终止一个进程！！！                           |
| -9     | 立刻强制终止一个进程！！！（！！不能强制结束系统级别的进程） |
| -2     | 代表由键盘输入 [ctrl] + c  同样的动作;                       |
| -1     | 对于sshd这样的守护进程，重新读取一次参数的配置文件      (类似 reload)，如果进程为非守护进程，默认为终止进程; ！！ |



## 案例

1. 结束所有httpd的进程（如果没有可以先安装一下：`yum install -y httpd`）

   ```shell
   [root@Demo01 ~]# killall -9 httpd
   ```

   ![](https://gitee.com/sxhDrk/images/raw/master/imgs/程序被加载为进程示意图.png)

2. 结束所有Java的进程

   ```shell
   [root@Demo01 ~]# killall -9 java
   ```

   





# 系统资源监控(自带)

## 内存监控:`free`

> 可能监控不准确
>
> 在真实的公司中有第三方，甚至公司自己开发的监控工具。不属于我们负责

选项:

| 选项 | 作用     |
| ---- | -------- |
| -b   | bytes    |
| -k   | kb       |
| -m   | mb       |
| -g   | gb       |
| -t   | 统计总量 |

```shell
[root@Demo01 ~]# free -m
[root@Demo01 ~]# free -mt
```



清理缓存的命令：

```shell
[root@Demo01 ~]# echo 3 > /proc/sys/vm/drop_caches 
```



## 查阅系统与核心信息:`uname`

> 选项:
>
> | 选项 | 作用                                           |
> | ---- | ---------------------------------------------- |
> | -a   | 所有系统相关的信息,包括以下的数据都会被列出来; |
> | -s   | 系统内核名称                                   |
> | -r   | 内核版本                                       |
> | -m   | 本系统的硬件名称,例如  i686或x86_64 等;        |
> | -p   | CPU 的类型,与 -m  类似,是显示的是CPU的类型;    |
> | -i   | 硬件的平台(ix86);                              |



## 观察系统启动时间与工作负载:`uptime`

> 00:29:43 up 1 day, 7:20, 2 users, load average: 0.00, 0.00, 0.00

| 选项                            | 解释                           |
| ------------------------------- | ------------------------------ |
| 00:29:43                        | 系统当前的时间                 |
| Up 1 day, 7:20                  | 系统运行时间                   |
| 2 users                         | 当前有两个用户登录             |
| load average: 0.00,  0.00, 0.00 | 系统过去的1,5,15分钟的平均负载 |

## 网络监控:`netstat`

> 监听udp一般监听不出来

| 选项 | 作用                                                 |
| ---- | ---------------------------------------------------- |
| -a   | 将目前系统上所有的已经连接、监听、Socket数据都列出来 |
| -t   | 列出tcp网络包的信息                                  |
| -u   | 列出udp网络包的信息                                  |
| -n   | 以端口(port  number)方式来显示（不以程序的服务名称） |
| -l   | 列出目前正在监听(listen)的服务;                      |
| -p   | 列出该网络服务的进程id（PID）、程序名                |

1. 列出当前系统中正在监听的TCP服务

   ```shell
   [root@Demo01 ~]# netstat -lt
   ```

   

2. 列出当前系统中正在监听的TCP服务,并且显示进程ID

   ```shell
   [root@Demo01 ~]# netstat -ltp
   ```

   

3. 列出当前系统中正在监听的TCP服务，并且显示进程ID、端口号。

   ```shell
   [root@Demo01 ~]# netstat -lntp
   ```

   

4. 列出当前系统中已连接的TCP服务，并显示进程ID、端口号。

   ```shell
   [root@Demo01 ~]# netstat -tnp
   ```



### 查询出来的名称含义

| 名称             | 作用             |
| ---------------- | ---------------- |
| Proto            | 协议名           |
| Recv-Q           | 接收消息缓冲区   |
| Send-Q           | 发送消息缓冲区   |
| Local Address    | 本地地址和端口号 |
| Foreign Address  | 远程地址和端口号 |
| State            | 状态。连接、监听 |
| PID/Program name | 进程ID和程序名   |



## 侦测系统资源变化:`vmstat`

> 侦测系统资源变化   
>
> 统计目前主机CPU状态,每秒一次,共计四次 

```shell
[root@Demo01 ~]# vmstat 1 4
```

![](https://gitee.com/sxhDrk/images/raw/master/imgs/vmstat侦测系统资源变化.png)

### 查询结果介绍

1. procs（进程字段 ）

   > 这两个项目越多,代表系统越忙碌 (因为系统太忙,所以很多进程就无法被执行或一直在等待而无法被唤醒) 

   | r :  | 等待运行的进程数量; cup处理不过来 |
   | ---- | --------------------------------- |
   | b:   | 不可被唤醒的进程数量              |

2. memory (内存字段) 

   | swpd:       | 虚拟内存被使用的容量; |
   | ----------- | --------------------- |
   | free:       | 未被使用的内存容量;   |
   | buff/cache: | 用于缓冲的内存;       |

3. swap（交换分区字段） （重点记忆下si和so）

   > ==如果si/so的数值太大,表示内存内的数据常常得在磁盘与主存储器之间传来传去,系统效能会很差==

   | si:  | 每秒从交换分区写到内存的数据量大小，由磁盘->内存; |
   | ---- | ------------------------------------------------- |
   | so:  | 每秒写入交换分区的内存数据量大小，由内存->磁盘。  |

4. io(磁盘读写字段) 

   > 如果这部份的值越高,代表系统的I/O非常忙碌

   | bi:  | 从块设备读入数据的总量（读磁盘）（每秒kb）;   |
   | ---- | --------------------------------------------- |
   | bo:  | 从块设备写入数据的总量（写磁盘）（每秒kb） 。 |

5. system（系统字段 ）

   > 这两个数值越大,代表系统与接口设备的通信非常频繁

   | in:  | 每秒被中断的进程次数; 发生在cup争抢的过程中     |
   | ---- | ----------------------------------------------- |
   | cs:  | 每秒钟进行的事件切换次数。发生在cup争抢的过程中 |

6. CPU (cpu字段) 

   | us   | (user)非内核态的（用户进程） CPU 使用情况;              |
   | ---- | ------------------------------------------------------- |
   | sy   | (system）内核态所使用（系统进程）的 CPU 情况;           |
   | id   | (idle  ）闲置的CPU情况;                                 |
   | wa   | (wait)等待I/O所耗费的CPU;                               |
   | st   | 被虚拟机(virtual machine)所盗用的CPU(2.6.11 以后才支持) |



# Linux防火墙

> 它具备一定的防护功能，比如说端口的开放和禁止，也可做数据的转发(类似路由功能)，策略及其他功能。

## 临时处理防火墙

> 如果系统重启，那么防火墙将恢复到之前的状态

| 作用 | 命令                                                         |
| ---- | ------------------------------------------------------------ |
| 开启 | `service iptables start`  <br />or <br /> `/etc/init.d/iptables  start` |
| 关闭 | `service iptables stop`  <br />or  <br />`/etc/init.d/iptables stop` |
| 重启 | `service iptables restart` <br /> or<br /> `/etc/init.d/iptables restart` |
| 查看 | `service iptables status`  <br />or  <br />`/etc/init.d/iptables status` |



## 永久处理防火墙

> (需重启系统后才能生效)

| 作用     | 命令                        |
| -------- | --------------------------- |
| 开启：   | `chkconfig iptables on`     |
| 查看状态 | `chkconfig iptables --list` |
| 关闭：   | `chkconfig iptables off`    |