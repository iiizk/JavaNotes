[TOC]



# 缓存击穿

由于某个瞬间，某个key过期，此时高并发的请求过来查询该key，造成缓存击穿

![image-20210313131332911](https://gitee.com/sxhDrk/images/raw/master/imgs/image-20210313131332911.png)

解决思路：

> 防止并发到达数据库

1. 当client获取key显示没有key时，加一个锁：`setnx`
2. 只有不存在锁的时候才能set成功，成功后，再去访问数据，拿到数据，再写到Redis中
3. 当set不成功时，sleep一段时间，再重新从第一步开始执行

> 产生新问题：第一个线程挂掉，锁没有撤销，那么后面的就会一直sleep下去

解决：

1. 设置锁的过期时间

> 又产生新的问题：如果访问数据库时间超过了锁的时间，锁就超时了。这是别的线程可以加锁，然后又访问数据库，此时因为第一个可能还没有处理完，那么第二个也会阻塞到数据库这里，导致阻塞的线程越来越多

解决：使用多线程：

1. 一个线程用于访问数据库，拿数据
2. 另一个线程用于监控是否返回了数据（对应key是否有值），没有拿回数据就把锁时间延长

![image-20210313135404068](https://gitee.com/sxhDrk/images/raw/master/imgs/image-20210313135404068.png)

> 解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。





# 缓存穿透

无效key，在Redis中查不到，在数据库中也查不到。导致每次查都会走数据库

> 解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 `set -999 UNKNOWN`。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。



# 缓存雪崩

Redis宕机，或者一批缓存失效，导致大量的请求走到数据库中，导致数据库的宕机



# 一致性（双写）

