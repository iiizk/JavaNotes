[TOC]

# ZAB概述

1. ZAB（Zookeeper Atomic Broadcast）协议是分布式协调服务ZooKeeper专门设计的一种支持**崩溃恢复**和**原子广播**的协议
2. ZAB协议基于了`2PC`算法来进行设计，利用==PAXOS==算法进行了改进
3. ZAB协议包括两种基本的模式，分别是：
   - 消息原子广播（保证数据一致性）
   - 崩溃恢复（解决2PC算法的单点问题）





# 消息原子广播

**作用**：保证数据一致性。连接任意一个Zookeeper服务器，获取到的数据是相同的

**原子广播**：实现分布式数据一致性的过程称为消息广播（原子广播）

**与2PC的区别**：ZAB协议的消息广播过程使用的是原子广播协议，类似于一个二阶提交过程。但是相较于2PC算法，不同的是ZAB协议引入了过半性思想



ZooKeeper使用一个单一的主进程（leader服务器）来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有的副本进程（follower或observer)上去。即：所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为leader服务器，而余下的其他服务器则成为follower服务器或observer



## 具体流程

- 针对客户端的事务请求，leader服务器会先将该事物写到本地的log文件中
- 然后，leader服务器会为这次请求生成对应的事务Proposal，并且为这个事务Proposal分配一个全局递增的唯一的事务ID，即Zxid
- leader服务器会为每一个follower服务器都各自分配一个单独的队列，将需要广播的事务Proposal依次放入队列中，发送给每一个follower
- 每一个follower在收到队列之后，会从队列中依次取出事务Proposal，写到本地的事务日志中。
  - 如果写成功了，则给leader返回一个ACK消息
  - 如果写失败了，follower认为该事务不能执行，就会返回no
- 当leader服务器接收到过半的follower的ACK响应之后，就会广播一个Commit消息给所有的follower，已通知其进行事务提交。同时leader自身也进行事务提交
- leader在收到Commit消息后完成事务提交



![](https://gitee.com/sxhDrk/images/raw/master/imgs/image-20210322170232807.png)

> 如果follower记录失败，但是leader去要求执行这个请求，follower会向leader发送一个请求，请求重新获取刚才的信息重新记录重新执行

![image-20210322170232807](https://gitee.com/sxhDrk/images/raw/master/imgs/ZAB的原子广播过程.png)

为什么leader会收到follower返回的no？（为什么follower记录失败？）

- 网络问题。例如产生数据丢失导致follower没有请求
- follower在记录日志的时候发现日志被占用
- 磁盘问题。例如磁盘已满、磁盘损坏



# 崩溃恢复

1. 当leader服务器出现崩溃、重启等场景，或者因为网络问题导致过半的follower不能与leader服务器保持正常通信的时候，Zookeeper集群就会进入崩溃恢复模式
2. 进入崩溃恢复模式后，只要集群中存在过半的服务器能够彼此正常通信，那么就可以选举产生一个新的leader
3. 每次新选举的leader会自动分配一个全局递增的编号，即epochid
4. 当选举产生了新的leader服务器，同时集群中已经有过半的机器与该leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和leader服务器的数据状态保持一致
5. 当集群中已经有过半的follower服务器完成了和leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了
6. 当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：
   - 找到leader所在的服务器，并与其进行数据同步
   - 然后一起参与到消息广播流程中

> **作用**：避免单点故障
>
> 事务id由64位二进制数字（16位十六进制）组成 ，其中高32位对应了epochid，低32位对应了实际的事务id



# 2PC算法

## 概述

> Two Phase Commit	-	二阶段提交

- 是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点进行事务处理过程中，能够保持原子性和一致性而设计的一种算法
- 目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便的完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效的保证分布式数据一致性

> 通常，二阶段提交算法也被认为是一种一致性协议，用来保证分布式系统数据的一致性



## 提交过程

### 阶段一

> ==提交事务+执行事务==
>
> 由于在形式上近似是协调者组织各参与者对一次事务操作的投票表达偶成，因此二阶段提交协议的阶段一也被称为：“投票阶段”，即各参与者投票表明是否要继续执行接下来事务提交操作

- **事务询问**：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应
- **执行事务**：各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中
- **向协调者反馈事务询问的响应**：
  - 如果参与者执行成功了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行
  - 如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行



### 阶段二

> ==事务提交==
>
> 在阶段二中，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能：

#### 执行事务提交

> 假如协调者从所有的参与者的反馈中获得的都是Yes响应，就会执行事务提交

- **发送提交请求**：协调者向所有的参与者节点发送Commit请求
- **事务提交**：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
- **反馈事务提交结果**：参与者在完成事务提交之后，想协调者发送ACK消息
- **完成事务**：协调者接收到所有参与者反馈的ACK消息后，完成事务

![](https://gitee.com/sxhDrk/images/raw/master/imgs/2pc阶段二-事务提交.png)





#### 中断事务

> 假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务

- **发送回滚请求**：协调者向所有参与者节点发出Rollback请求
- **事务回滚**：参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源
- **反馈事务回滚结果**：参与者在完成事务回滚之后，向协调者发送Ack消息
- **中断事务**：协调者接收到所有参与者反馈的Ack消息后，完成事务中断

![](https://gitee.com/sxhDrk/images/raw/master/imgs/2pc阶段二-中断事务.png)





## 优缺点

### 优点

原理简单，实现方便

### 缺点

#### 同步阻塞

二阶段提交协议存在的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作

#### 单点问题

协调者的角色在整个二阶段提交协议中处于核心地位，因此一旦协调者出现问题，那么整个二阶段提交流程将无法运转

#### 太过保守

如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，这样的策略显得比较保守。换句话说，二阶段提交协议没有设计较为完善的容错机，任意一个节点的失败都会导致整个事务的失败