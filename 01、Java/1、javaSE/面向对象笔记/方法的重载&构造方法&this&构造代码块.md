[TOC]

# 方法的重载

> - 方法的签名：包含如下两个部分：方法名和参数列表
>   - ==方法的重载与返回值无关==
> - 一个类中，不可以有两个方法签名完全相同的方法，即：一个类中不可以有两个方法的方法名和参数列表都完全一样，但是，如果一个类中两个方法名相同而参数列表不同是可以的



## 定义

​	重载是编译器所认可的，编译时根据签名绑定使用方法，编译器在编译时会根据签名来调用不同的方法

​	我们可以把重载的方法看成完全不同的方法，只不过是方法名相同而已

```java
study(1);
study("字符串");
```



## 为什么使用方法的重载，而不是给方法起不同的名字？

> 因为在某些时候需要调用大量相同方法名的方法，但是参数列表（数据类型）可能随时都能变化，如果不使用重载，就必须调用新的方法，而使用重载，则编译时会根据所传参数的变化，自动调用不同的方法，起到了维护性好的特点
>
> ```java
> System.out.println(1);
> System.out.println(1.1);
> ```



# 构造方法

> 又叫做：构造器、构建器、构造函数
>
> 构造方法没有返回值，什么也不写；如果写了返回值，就变成了普通方法

1. 构造方法的作用：常常用于给成员变量赋值
2. 构造方法的结构：==必须与类同名，没有返回值==
3. 在创建对象时会被自动调用
4. 如自己不写构造方法时，则编译器会默认提供一个无参构造；如自己写了构造，则不在默认提供
5. 构造方法也是可以重载的



## 构造方法的使用

- 构造方法。默认情况下会有一个隐藏的构造方法，写不写都行

- 结构：类名+（参数）+{方法体}

  `Animal dog = new Animal()`

  ​		new 其实干了两件事：

  - 创建了一个对象
  - 调用构造方法`Animal();`
  
- 构造方法支持return语句

> 如果我们创建了一个有参或者无参的构造方法，则隐藏的构造方法将不存在

```java
Animal(){//无参构造
	this(1);//this调用下面Animal(int i){}构造方法
}

Animal(int i){//一个参数的构造方法
	
}

Animal (String arg1,int arg2,String arg3){//三个参数的构造方法
	name = arg1;
	age = arg2;
	color = arg3;
}
```

​	

# this

> 指代当前对象，==哪个对象调用方法，就指代哪个对象==，只能在方法中，在方法中访问成员变量之前默认有个this



## 用法

- this.成员变量名------访问成员变量
  - 补充：一般情况下，在构造方法中，用来初始化成员变量，一般和成员变量相同的名字，这样有利于代码的可读性，但是此处就必须通过this关键字来区分成员变量和参数（不能省略this）
- this.方法名()------调用方法（知道就好，一般不用）
- this()------调用本类的构造方法（可有可无，使用后可以尽量让代码复用）
  - this构造方法只能在构造方法中使用一次，并且只能写在构造方法的第一行

```java
Car(){
	//this()
	this("this调用本类Car（String arg1）构造方法");//this构造方法必须写在第一位   
	System.out.println("无参构造");

}

Car(String name,String color,int speed){
	this.name = name;
	this.color = color;
	this.speed = speed;
}

Car(String arg1){
    System.out.println("一个参数的构造方法："+arg1);
}

Car(int a){//一个参数的构造方法
	this(a,a);//this()，调用本类的构造方法
}

Car(int i,int j){
	System.out.println(i+j);
}
```

# 代码块

## 构造代码块

- 格式：`{代码块;}`
- 位置：类中，方法外
- 初始化对象属性值
- 构造代码块无法通过名称等调用，仅在创建对象时自动调用一次；==每次创建一个对象，构造代码块就会被执行一次==
- 构造代码块会在构造方法之前执行一次

```java
class Person {
    String name;
    int age;
    char gender;
    {
        this.age = 1;
    }
}
```

### 应用场景

- 所有构造方法中都有的逻辑代码，我们就可以提取到构造代码块
- ==一个类中可以写多个构造代码块，但是没有意义==



## 局部代码块

- 格式：`{代码块}`
- 位置：方法中
- 作用：不影响程序执行流程，但是可以==限定变量的生命周期==；局部代码块中的变量，仅在局部代码块中生效；一旦代码块执行完毕，则该变量会马上被释放；==提高内存利用率==

```java
 public void eat() {
        {
            int i = 5;
            System.out.println(i);
        }
        
        System.out.println(name+"正在吃饭");
    }
```



# 匿名对象

- 格式：`new xxx();`
- 对象没有名字，只能使用一次；

## 使用

- 可以通过对象获取对象的属性和调用对象的方法；可以通过匿名对象给对象的属性赋值，但是因为匿名对象只能使用一次，赋值结束后就找不到该对象了

  ```java
  new ClassDemo().test();
  new Person().name = "aa";
  ```

- 匿名对象可以作为返回值通过return返回

  ```java
      public Person getPerson(){
          return new Person();
      }
  ```

## 释放

- 堆内存中的对象只有当没有任何引用指向它时，才有可能被垃圾回收机制自动回收

- 如果想让对内存中的对象尽快释放，可以让引用=null

  ```java
  Person p = new Person();
  p = null;
  ```

  

