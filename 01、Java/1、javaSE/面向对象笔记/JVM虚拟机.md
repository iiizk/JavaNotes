[TOC]



# Java虚拟机

> java虚拟机JVM来管理Java内存的简单理解

1. 变量，方法，对象都是在内存里运行的，而Java虚拟机把内存分成了三个区域：堆、栈、方法区
2. 首先，堆里面放的是我们所创建的对象，并不是我们自己来做的，是JVM自己来做的，而我们只需要new一个对象后，系统自动把对象放在堆里面了。而栈中存放的是局部变量
3. 基本类型所声明的变量叫做基本类型变量，而我们自己创建的类的变量叫做引用类型变量，简称引用
4. 在方法内所创建的变量统称叫做局部变量

## JVM在创建对象时的流程

> ​	当前系统开始执行时，会逐行读取代码，首先会在栈中找到对应的引用类型变量（引用），引用保存的是对应的对象地址，根据栈中的地址，找到堆中所对应的对象，当我们给成员变量赋值时或调用时，则会给对象中的变量赋值或调用方法。
>
> ​	当我们生成一个新的引用变量（引用）同时创建一个新的对象时，则会在堆中创建一个新的对象。

```java
public static void main(String[] args) {
	Teacher t1 = new Teacher();
	t1.name = "周老师";
	Teacher t2 = new Teacher();
	t2.name = "王老师";
}
```

> 为什么new一个对象就会在堆中创建一个对象呢？
>
> 1. 因为语法的规定和JVM的规定
> 2. 如果不在堆中创建以一个新的对象的话，就会覆盖原有的对象的变量及方法



## 引用类型的指向

1. 创建一个对象new Teacher()并指向了t这个引用
2. tc引用并没有新的对象所指向,所以t把自身的地址赋值给了tc
3. 当我们第一次给t.age赋值时,t.age = 15;
4. 当我们第一次给tc.age赋值时，tc.age = 18;
5. 因为t和tc指向的是同一个对象，所以,tc.age最后把t.age的值进行了覆盖,t.age = 18;

```java
Teacher t = new Teacher();
Teacher tc = t;
t.age = 15;
tc.age = 18;
//最后t.age = 18;
```



### 基本类型的赋值

> 基本类型赋值操作，都是在栈中进行的，所以不涉及到栈，堆之间地址的指向。所以后赋值的a与b无关

```java
int a = 5;
int b = a;
a = 8;
b = 88;
//最后a = 8;
```



### 空指针异常

> null表示为空，没有指向任何一个对象，所以不能对null做任何的操作，若操作，则会报空指针异常：java.lang.NullPointerException

```java
Teacher te = new Teacher();
te.age = 10;
te = null;
System.out.println("执行了");//打桩，进行测试
te.age = 2;

```

