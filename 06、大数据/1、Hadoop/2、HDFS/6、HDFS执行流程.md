[TOC]



# 读取/下载流程

![](https://gitee.com/sxhDrk/images/raw/master/imgs/读取-下载流程.png)

1. 客户端发起RPC请求到NameNode

2. NameNode收到请求之后，查询元数据

   - 如果查询成功，给客户端返回信号，表示允许读

3. 客户端收到信号之后，向NameNode再次发送请求，请求获取文件第一个Block的存储位置

4. NameNode收到请求之后，会将这个Block的存储位置放到一个队列中返回给客户端

   > 默认情况下，副本数量为3
   >
   > 所以放到队列中的Block位置是3个

5. 客户端收到队列之后，会将这个Block的位置从队列中全部取出，从这些位置中选取一个比较近的DataNode来进行读取。读取`Block`以及对应的`.meta`

   > `.meta`对当前Block的描述，例如这个Block的产生时间、Block的大小等
   >
   > 距离：网络拓扑距离

6. 读取完成之后，会对Block的大小进行校验

   - 如果校验失败，那么客户端就会通知NameNode，同时客户端重新选取地址重新读取
   - 如果检验成功，那么客户端会继续向NameNode发送请求要下一个Block的地址，重复4、5、6步骤

7. 当客户端读取网所有的Block之后，客户端就会给NameNode发送信号要求关闭文件（关流）



# 写入/上传流程

![](https://gitee.com/sxhDrk/images/raw/master/imgs/写入-上传流程.png)

1. 客户端发起RPC请求到NameNode
2. NameNode收到请求之后，先进行校验：
   - 校验是否有权限操作要写入的路径
   - 校验这个路径下是否有同名文件
3. 校验通过，NameNode给客户端返回一个信号，表示允许写入
4. 客户端收到信号之后，就向NameNode发送请求，请求获取第一个Block的写入位置
5. NameNode收到请求之后，将位置放到一个队列中，返回给客户端
6. 客户端收到队列之后
   - 从队列中将全部的位置取出，从中选择一个较近的节点，写入这个Block的第一个副本。
   - 同时客户端告诉这个节点第二个和第三个副本的存储位置。当前节点通过pipeline（管道，本质上是一个Channel），将第二个副本写到对应节点上
   - 第二个副本所在的节点再通过管道将第三个副本数据写到第三个节点上。
     - 等第三个副本写完之后，会给第二个副本所在的节点返回一个ACK表示写入成功
     - 第二个副本所在节点收到ACK之后，会给第一个副本所在的节点返回一个ACK表示写入成功
     - 第一个副本所在节点收到ACK之后，给客户端返回一个ACK表示数据完全写入成功
7. 客户端收到ACK之后，就会向NameNode要下一个Block的位置，重复5、6、7三个步骤
8. 当客户端将所有的Block写完之后，通知NameNode关闭文件（关流）





# 删除流程

1. 客户端发起RPC请求到NameNode

2. NameNode收到请求之后，会进行校验：

   - 校验是否有这个文件
   - 校验是否有删除权限

3. 校验通过，NameNode就会将这个写操作记录到`edits_inprogress`中，同时更改内存中的元数据。元数据更改完成之后，NameNode就会给客户端返回一个ACK表示删除成功

   > 这个过程中，仅仅是元数据作了修改，这个文件对应的Block并没有被删除，也就意味着，客户端收到AKC不代表文件已经删除

4. 当NameNode收到DataNode的心跳的时候，会校验心跳信息

   - 如果发现心跳信息和元数据不一致，那么NameNode就会进行心跳响应，要求DataNode删除对应的Block

5. 当DataNode收到心跳响应之后，才会删除Block，此时这个文件才算真正从HDFS上移除